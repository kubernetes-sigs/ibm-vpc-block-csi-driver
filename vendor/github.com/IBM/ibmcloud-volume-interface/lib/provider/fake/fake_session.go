// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"net/http"
	"sync"

	"github.com/IBM/ibmcloud-volume-interface/lib/provider"
)

type FakeSession struct {
	AttachVolumeStub        func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)
	attachVolumeMutex       sync.RWMutex
	attachVolumeArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	attachVolumeReturns struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	attachVolumeReturnsOnCall map[int]struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	AuthorizeVolumeStub        func(provider.VolumeAuthorization) error
	authorizeVolumeMutex       sync.RWMutex
	authorizeVolumeArgsForCall []struct {
		arg1 provider.VolumeAuthorization
	}
	authorizeVolumeReturns struct {
		result1 error
	}
	authorizeVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	CreateSnapshotStub        func(string, provider.SnapshotParameters) (*provider.Snapshot, error)
	createSnapshotMutex       sync.RWMutex
	createSnapshotArgsForCall []struct {
		arg1 string
		arg2 provider.SnapshotParameters
	}
	createSnapshotReturns struct {
		result1 *provider.Snapshot
		result2 error
	}
	createSnapshotReturnsOnCall map[int]struct {
		result1 *provider.Snapshot
		result2 error
	}
	CreateVolumeStub        func(provider.Volume) (*provider.Volume, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		arg1 provider.Volume
	}
	createVolumeReturns struct {
		result1 *provider.Volume
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	CreateVolumeAccessPointStub        func(provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error)
	createVolumeAccessPointMutex       sync.RWMutex
	createVolumeAccessPointArgsForCall []struct {
		arg1 provider.VolumeAccessPointRequest
	}
	createVolumeAccessPointReturns struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}
	createVolumeAccessPointReturnsOnCall map[int]struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}
	CreateVolumeFromSnapshotStub        func(provider.Snapshot, map[string]string) (*provider.Volume, error)
	createVolumeFromSnapshotMutex       sync.RWMutex
	createVolumeFromSnapshotArgsForCall []struct {
		arg1 provider.Snapshot
		arg2 map[string]string
	}
	createVolumeFromSnapshotReturns struct {
		result1 *provider.Volume
		result2 error
	}
	createVolumeFromSnapshotReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	DeleteSnapshotStub        func(*provider.Snapshot) error
	deleteSnapshotMutex       sync.RWMutex
	deleteSnapshotArgsForCall []struct {
		arg1 *provider.Snapshot
	}
	deleteSnapshotReturns struct {
		result1 error
	}
	deleteSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVolumeStub        func(*provider.Volume) error
	deleteVolumeMutex       sync.RWMutex
	deleteVolumeArgsForCall []struct {
		arg1 *provider.Volume
	}
	deleteVolumeReturns struct {
		result1 error
	}
	deleteVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVolumeAccessPointStub        func(provider.VolumeAccessPointRequest) (*http.Response, error)
	deleteVolumeAccessPointMutex       sync.RWMutex
	deleteVolumeAccessPointArgsForCall []struct {
		arg1 provider.VolumeAccessPointRequest
	}
	deleteVolumeAccessPointReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteVolumeAccessPointReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DetachVolumeStub        func(provider.VolumeAttachmentRequest) (*http.Response, error)
	detachVolumeMutex       sync.RWMutex
	detachVolumeArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	detachVolumeReturns struct {
		result1 *http.Response
		result2 error
	}
	detachVolumeReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	ExpandVolumeStub        func(provider.ExpandVolumeRequest) (int64, error)
	expandVolumeMutex       sync.RWMutex
	expandVolumeArgsForCall []struct {
		arg1 provider.ExpandVolumeRequest
	}
	expandVolumeReturns struct {
		result1 int64
		result2 error
	}
	expandVolumeReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	GetProviderDisplayNameStub        func() provider.VolumeProvider
	getProviderDisplayNameMutex       sync.RWMutex
	getProviderDisplayNameArgsForCall []struct {
	}
	getProviderDisplayNameReturns struct {
		result1 provider.VolumeProvider
	}
	getProviderDisplayNameReturnsOnCall map[int]struct {
		result1 provider.VolumeProvider
	}
	GetSnapshotStub        func(string) (*provider.Snapshot, error)
	getSnapshotMutex       sync.RWMutex
	getSnapshotArgsForCall []struct {
		arg1 string
	}
	getSnapshotReturns struct {
		result1 *provider.Snapshot
		result2 error
	}
	getSnapshotReturnsOnCall map[int]struct {
		result1 *provider.Snapshot
		result2 error
	}
	GetSnapshotByNameStub        func(string) (*provider.Snapshot, error)
	getSnapshotByNameMutex       sync.RWMutex
	getSnapshotByNameArgsForCall []struct {
		arg1 string
	}
	getSnapshotByNameReturns struct {
		result1 *provider.Snapshot
		result2 error
	}
	getSnapshotByNameReturnsOnCall map[int]struct {
		result1 *provider.Snapshot
		result2 error
	}
	GetVolumeStub        func(string) (*provider.Volume, error)
	getVolumeMutex       sync.RWMutex
	getVolumeArgsForCall []struct {
		arg1 string
	}
	getVolumeReturns struct {
		result1 *provider.Volume
		result2 error
	}
	getVolumeReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	GetVolumeAccessPointStub        func(provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error)
	getVolumeAccessPointMutex       sync.RWMutex
	getVolumeAccessPointArgsForCall []struct {
		arg1 provider.VolumeAccessPointRequest
	}
	getVolumeAccessPointReturns struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}
	getVolumeAccessPointReturnsOnCall map[int]struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}
	GetVolumeAttachmentStub        func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)
	getVolumeAttachmentMutex       sync.RWMutex
	getVolumeAttachmentArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	getVolumeAttachmentReturns struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	getVolumeAttachmentReturnsOnCall map[int]struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	GetVolumeByNameStub        func(string) (*provider.Volume, error)
	getVolumeByNameMutex       sync.RWMutex
	getVolumeByNameArgsForCall []struct {
		arg1 string
	}
	getVolumeByNameReturns struct {
		result1 *provider.Volume
		result2 error
	}
	getVolumeByNameReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	GetVolumeByRequestIDStub        func(string) (*provider.Volume, error)
	getVolumeByRequestIDMutex       sync.RWMutex
	getVolumeByRequestIDArgsForCall []struct {
		arg1 string
	}
	getVolumeByRequestIDReturns struct {
		result1 *provider.Volume
		result2 error
	}
	getVolumeByRequestIDReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	ListSnapshotsStub        func(int, string, map[string]string) (*provider.SnapshotList, error)
	listSnapshotsMutex       sync.RWMutex
	listSnapshotsArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 map[string]string
	}
	listSnapshotsReturns struct {
		result1 *provider.SnapshotList
		result2 error
	}
	listSnapshotsReturnsOnCall map[int]struct {
		result1 *provider.SnapshotList
		result2 error
	}
	ListVolumesStub        func(int, string, map[string]string) (*provider.VolumeList, error)
	listVolumesMutex       sync.RWMutex
	listVolumesArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 map[string]string
	}
	listVolumesReturns struct {
		result1 *provider.VolumeList
		result2 error
	}
	listVolumesReturnsOnCall map[int]struct {
		result1 *provider.VolumeList
		result2 error
	}
	ProviderNameStub        func() provider.VolumeProvider
	providerNameMutex       sync.RWMutex
	providerNameArgsForCall []struct {
	}
	providerNameReturns struct {
		result1 provider.VolumeProvider
	}
	providerNameReturnsOnCall map[int]struct {
		result1 provider.VolumeProvider
	}
	TypeStub        func() provider.VolumeType
	typeMutex       sync.RWMutex
	typeArgsForCall []struct {
	}
	typeReturns struct {
		result1 provider.VolumeType
	}
	typeReturnsOnCall map[int]struct {
		result1 provider.VolumeType
	}
	UpdateVolumeStub        func(provider.Volume) error
	updateVolumeMutex       sync.RWMutex
	updateVolumeArgsForCall []struct {
		arg1 provider.Volume
	}
	updateVolumeReturns struct {
		result1 error
	}
	updateVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForAttachVolumeStub        func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)
	waitForAttachVolumeMutex       sync.RWMutex
	waitForAttachVolumeArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	waitForAttachVolumeReturns struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	waitForAttachVolumeReturnsOnCall map[int]struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	WaitForCreateVolumeAccessPointStub        func(provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error)
	waitForCreateVolumeAccessPointMutex       sync.RWMutex
	waitForCreateVolumeAccessPointArgsForCall []struct {
		arg1 provider.VolumeAccessPointRequest
	}
	waitForCreateVolumeAccessPointReturns struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}
	waitForCreateVolumeAccessPointReturnsOnCall map[int]struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}
	WaitForDeleteVolumeAccessPointStub        func(provider.VolumeAccessPointRequest) error
	waitForDeleteVolumeAccessPointMutex       sync.RWMutex
	waitForDeleteVolumeAccessPointArgsForCall []struct {
		arg1 provider.VolumeAccessPointRequest
	}
	waitForDeleteVolumeAccessPointReturns struct {
		result1 error
	}
	waitForDeleteVolumeAccessPointReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForDetachVolumeStub        func(provider.VolumeAttachmentRequest) error
	waitForDetachVolumeMutex       sync.RWMutex
	waitForDetachVolumeArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	waitForDetachVolumeReturns struct {
		result1 error
	}
	waitForDetachVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSession) AttachVolume(arg1 provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) {
	fake.attachVolumeMutex.Lock()
	ret, specificReturn := fake.attachVolumeReturnsOnCall[len(fake.attachVolumeArgsForCall)]
	fake.attachVolumeArgsForCall = append(fake.attachVolumeArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	stub := fake.AttachVolumeStub
	fakeReturns := fake.attachVolumeReturns
	fake.recordInvocation("AttachVolume", []interface{}{arg1})
	fake.attachVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) AttachVolumeCallCount() int {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	return len(fake.attachVolumeArgsForCall)
}

func (fake *FakeSession) AttachVolumeCalls(stub func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = stub
}

func (fake *FakeSession) AttachVolumeArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	argsForCall := fake.attachVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) AttachVolumeReturns(result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	fake.attachVolumeReturns = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) AttachVolumeReturnsOnCall(i int, result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	if fake.attachVolumeReturnsOnCall == nil {
		fake.attachVolumeReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAttachmentResponse
			result2 error
		})
	}
	fake.attachVolumeReturnsOnCall[i] = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) AuthorizeVolume(arg1 provider.VolumeAuthorization) error {
	fake.authorizeVolumeMutex.Lock()
	ret, specificReturn := fake.authorizeVolumeReturnsOnCall[len(fake.authorizeVolumeArgsForCall)]
	fake.authorizeVolumeArgsForCall = append(fake.authorizeVolumeArgsForCall, struct {
		arg1 provider.VolumeAuthorization
	}{arg1})
	stub := fake.AuthorizeVolumeStub
	fakeReturns := fake.authorizeVolumeReturns
	fake.recordInvocation("AuthorizeVolume", []interface{}{arg1})
	fake.authorizeVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) AuthorizeVolumeCallCount() int {
	fake.authorizeVolumeMutex.RLock()
	defer fake.authorizeVolumeMutex.RUnlock()
	return len(fake.authorizeVolumeArgsForCall)
}

func (fake *FakeSession) AuthorizeVolumeCalls(stub func(provider.VolumeAuthorization) error) {
	fake.authorizeVolumeMutex.Lock()
	defer fake.authorizeVolumeMutex.Unlock()
	fake.AuthorizeVolumeStub = stub
}

func (fake *FakeSession) AuthorizeVolumeArgsForCall(i int) provider.VolumeAuthorization {
	fake.authorizeVolumeMutex.RLock()
	defer fake.authorizeVolumeMutex.RUnlock()
	argsForCall := fake.authorizeVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) AuthorizeVolumeReturns(result1 error) {
	fake.authorizeVolumeMutex.Lock()
	defer fake.authorizeVolumeMutex.Unlock()
	fake.AuthorizeVolumeStub = nil
	fake.authorizeVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) AuthorizeVolumeReturnsOnCall(i int, result1 error) {
	fake.authorizeVolumeMutex.Lock()
	defer fake.authorizeVolumeMutex.Unlock()
	fake.AuthorizeVolumeStub = nil
	if fake.authorizeVolumeReturnsOnCall == nil {
		fake.authorizeVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.authorizeVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeSession) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeSession) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeSession) CreateSnapshot(arg1 string, arg2 provider.SnapshotParameters) (*provider.Snapshot, error) {
	fake.createSnapshotMutex.Lock()
	ret, specificReturn := fake.createSnapshotReturnsOnCall[len(fake.createSnapshotArgsForCall)]
	fake.createSnapshotArgsForCall = append(fake.createSnapshotArgsForCall, struct {
		arg1 string
		arg2 provider.SnapshotParameters
	}{arg1, arg2})
	stub := fake.CreateSnapshotStub
	fakeReturns := fake.createSnapshotReturns
	fake.recordInvocation("CreateSnapshot", []interface{}{arg1, arg2})
	fake.createSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) CreateSnapshotCallCount() int {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	return len(fake.createSnapshotArgsForCall)
}

func (fake *FakeSession) CreateSnapshotCalls(stub func(string, provider.SnapshotParameters) (*provider.Snapshot, error)) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = stub
}

func (fake *FakeSession) CreateSnapshotArgsForCall(i int) (string, provider.SnapshotParameters) {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	argsForCall := fake.createSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSession) CreateSnapshotReturns(result1 *provider.Snapshot, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	fake.createSnapshotReturns = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateSnapshotReturnsOnCall(i int, result1 *provider.Snapshot, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	if fake.createSnapshotReturnsOnCall == nil {
		fake.createSnapshotReturnsOnCall = make(map[int]struct {
			result1 *provider.Snapshot
			result2 error
		})
	}
	fake.createSnapshotReturnsOnCall[i] = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolume(arg1 provider.Volume) (*provider.Volume, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		arg1 provider.Volume
	}{arg1})
	stub := fake.CreateVolumeStub
	fakeReturns := fake.createVolumeReturns
	fake.recordInvocation("CreateVolume", []interface{}{arg1})
	fake.createVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeSession) CreateVolumeCalls(stub func(provider.Volume) (*provider.Volume, error)) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = stub
}

func (fake *FakeSession) CreateVolumeArgsForCall(i int) provider.Volume {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	argsForCall := fake.createVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) CreateVolumeReturns(result1 *provider.Volume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolumeReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolumeAccessPoint(arg1 provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error) {
	fake.createVolumeAccessPointMutex.Lock()
	ret, specificReturn := fake.createVolumeAccessPointReturnsOnCall[len(fake.createVolumeAccessPointArgsForCall)]
	fake.createVolumeAccessPointArgsForCall = append(fake.createVolumeAccessPointArgsForCall, struct {
		arg1 provider.VolumeAccessPointRequest
	}{arg1})
	stub := fake.CreateVolumeAccessPointStub
	fakeReturns := fake.createVolumeAccessPointReturns
	fake.recordInvocation("CreateVolumeAccessPoint", []interface{}{arg1})
	fake.createVolumeAccessPointMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) CreateVolumeAccessPointCallCount() int {
	fake.createVolumeAccessPointMutex.RLock()
	defer fake.createVolumeAccessPointMutex.RUnlock()
	return len(fake.createVolumeAccessPointArgsForCall)
}

func (fake *FakeSession) CreateVolumeAccessPointCalls(stub func(provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error)) {
	fake.createVolumeAccessPointMutex.Lock()
	defer fake.createVolumeAccessPointMutex.Unlock()
	fake.CreateVolumeAccessPointStub = stub
}

func (fake *FakeSession) CreateVolumeAccessPointArgsForCall(i int) provider.VolumeAccessPointRequest {
	fake.createVolumeAccessPointMutex.RLock()
	defer fake.createVolumeAccessPointMutex.RUnlock()
	argsForCall := fake.createVolumeAccessPointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) CreateVolumeAccessPointReturns(result1 *provider.VolumeAccessPointResponse, result2 error) {
	fake.createVolumeAccessPointMutex.Lock()
	defer fake.createVolumeAccessPointMutex.Unlock()
	fake.CreateVolumeAccessPointStub = nil
	fake.createVolumeAccessPointReturns = struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolumeAccessPointReturnsOnCall(i int, result1 *provider.VolumeAccessPointResponse, result2 error) {
	fake.createVolumeAccessPointMutex.Lock()
	defer fake.createVolumeAccessPointMutex.Unlock()
	fake.CreateVolumeAccessPointStub = nil
	if fake.createVolumeAccessPointReturnsOnCall == nil {
		fake.createVolumeAccessPointReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAccessPointResponse
			result2 error
		})
	}
	fake.createVolumeAccessPointReturnsOnCall[i] = struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolumeFromSnapshot(arg1 provider.Snapshot, arg2 map[string]string) (*provider.Volume, error) {
	fake.createVolumeFromSnapshotMutex.Lock()
	ret, specificReturn := fake.createVolumeFromSnapshotReturnsOnCall[len(fake.createVolumeFromSnapshotArgsForCall)]
	fake.createVolumeFromSnapshotArgsForCall = append(fake.createVolumeFromSnapshotArgsForCall, struct {
		arg1 provider.Snapshot
		arg2 map[string]string
	}{arg1, arg2})
	stub := fake.CreateVolumeFromSnapshotStub
	fakeReturns := fake.createVolumeFromSnapshotReturns
	fake.recordInvocation("CreateVolumeFromSnapshot", []interface{}{arg1, arg2})
	fake.createVolumeFromSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) CreateVolumeFromSnapshotCallCount() int {
	fake.createVolumeFromSnapshotMutex.RLock()
	defer fake.createVolumeFromSnapshotMutex.RUnlock()
	return len(fake.createVolumeFromSnapshotArgsForCall)
}

func (fake *FakeSession) CreateVolumeFromSnapshotCalls(stub func(provider.Snapshot, map[string]string) (*provider.Volume, error)) {
	fake.createVolumeFromSnapshotMutex.Lock()
	defer fake.createVolumeFromSnapshotMutex.Unlock()
	fake.CreateVolumeFromSnapshotStub = stub
}

func (fake *FakeSession) CreateVolumeFromSnapshotArgsForCall(i int) (provider.Snapshot, map[string]string) {
	fake.createVolumeFromSnapshotMutex.RLock()
	defer fake.createVolumeFromSnapshotMutex.RUnlock()
	argsForCall := fake.createVolumeFromSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSession) CreateVolumeFromSnapshotReturns(result1 *provider.Volume, result2 error) {
	fake.createVolumeFromSnapshotMutex.Lock()
	defer fake.createVolumeFromSnapshotMutex.Unlock()
	fake.CreateVolumeFromSnapshotStub = nil
	fake.createVolumeFromSnapshotReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolumeFromSnapshotReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.createVolumeFromSnapshotMutex.Lock()
	defer fake.createVolumeFromSnapshotMutex.Unlock()
	fake.CreateVolumeFromSnapshotStub = nil
	if fake.createVolumeFromSnapshotReturnsOnCall == nil {
		fake.createVolumeFromSnapshotReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.createVolumeFromSnapshotReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) DeleteSnapshot(arg1 *provider.Snapshot) error {
	fake.deleteSnapshotMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotReturnsOnCall[len(fake.deleteSnapshotArgsForCall)]
	fake.deleteSnapshotArgsForCall = append(fake.deleteSnapshotArgsForCall, struct {
		arg1 *provider.Snapshot
	}{arg1})
	stub := fake.DeleteSnapshotStub
	fakeReturns := fake.deleteSnapshotReturns
	fake.recordInvocation("DeleteSnapshot", []interface{}{arg1})
	fake.deleteSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) DeleteSnapshotCallCount() int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return len(fake.deleteSnapshotArgsForCall)
}

func (fake *FakeSession) DeleteSnapshotCalls(stub func(*provider.Snapshot) error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = stub
}

func (fake *FakeSession) DeleteSnapshotArgsForCall(i int) *provider.Snapshot {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	argsForCall := fake.deleteSnapshotArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) DeleteSnapshotReturns(result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	fake.deleteSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) DeleteSnapshotReturnsOnCall(i int, result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	if fake.deleteSnapshotReturnsOnCall == nil {
		fake.deleteSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) DeleteVolume(arg1 *provider.Volume) error {
	fake.deleteVolumeMutex.Lock()
	ret, specificReturn := fake.deleteVolumeReturnsOnCall[len(fake.deleteVolumeArgsForCall)]
	fake.deleteVolumeArgsForCall = append(fake.deleteVolumeArgsForCall, struct {
		arg1 *provider.Volume
	}{arg1})
	stub := fake.DeleteVolumeStub
	fakeReturns := fake.deleteVolumeReturns
	fake.recordInvocation("DeleteVolume", []interface{}{arg1})
	fake.deleteVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) DeleteVolumeCallCount() int {
	fake.deleteVolumeMutex.RLock()
	defer fake.deleteVolumeMutex.RUnlock()
	return len(fake.deleteVolumeArgsForCall)
}

func (fake *FakeSession) DeleteVolumeCalls(stub func(*provider.Volume) error) {
	fake.deleteVolumeMutex.Lock()
	defer fake.deleteVolumeMutex.Unlock()
	fake.DeleteVolumeStub = stub
}

func (fake *FakeSession) DeleteVolumeArgsForCall(i int) *provider.Volume {
	fake.deleteVolumeMutex.RLock()
	defer fake.deleteVolumeMutex.RUnlock()
	argsForCall := fake.deleteVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) DeleteVolumeReturns(result1 error) {
	fake.deleteVolumeMutex.Lock()
	defer fake.deleteVolumeMutex.Unlock()
	fake.DeleteVolumeStub = nil
	fake.deleteVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) DeleteVolumeReturnsOnCall(i int, result1 error) {
	fake.deleteVolumeMutex.Lock()
	defer fake.deleteVolumeMutex.Unlock()
	fake.DeleteVolumeStub = nil
	if fake.deleteVolumeReturnsOnCall == nil {
		fake.deleteVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) DeleteVolumeAccessPoint(arg1 provider.VolumeAccessPointRequest) (*http.Response, error) {
	fake.deleteVolumeAccessPointMutex.Lock()
	ret, specificReturn := fake.deleteVolumeAccessPointReturnsOnCall[len(fake.deleteVolumeAccessPointArgsForCall)]
	fake.deleteVolumeAccessPointArgsForCall = append(fake.deleteVolumeAccessPointArgsForCall, struct {
		arg1 provider.VolumeAccessPointRequest
	}{arg1})
	stub := fake.DeleteVolumeAccessPointStub
	fakeReturns := fake.deleteVolumeAccessPointReturns
	fake.recordInvocation("DeleteVolumeAccessPoint", []interface{}{arg1})
	fake.deleteVolumeAccessPointMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) DeleteVolumeAccessPointCallCount() int {
	fake.deleteVolumeAccessPointMutex.RLock()
	defer fake.deleteVolumeAccessPointMutex.RUnlock()
	return len(fake.deleteVolumeAccessPointArgsForCall)
}

func (fake *FakeSession) DeleteVolumeAccessPointCalls(stub func(provider.VolumeAccessPointRequest) (*http.Response, error)) {
	fake.deleteVolumeAccessPointMutex.Lock()
	defer fake.deleteVolumeAccessPointMutex.Unlock()
	fake.DeleteVolumeAccessPointStub = stub
}

func (fake *FakeSession) DeleteVolumeAccessPointArgsForCall(i int) provider.VolumeAccessPointRequest {
	fake.deleteVolumeAccessPointMutex.RLock()
	defer fake.deleteVolumeAccessPointMutex.RUnlock()
	argsForCall := fake.deleteVolumeAccessPointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) DeleteVolumeAccessPointReturns(result1 *http.Response, result2 error) {
	fake.deleteVolumeAccessPointMutex.Lock()
	defer fake.deleteVolumeAccessPointMutex.Unlock()
	fake.DeleteVolumeAccessPointStub = nil
	fake.deleteVolumeAccessPointReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) DeleteVolumeAccessPointReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteVolumeAccessPointMutex.Lock()
	defer fake.deleteVolumeAccessPointMutex.Unlock()
	fake.DeleteVolumeAccessPointStub = nil
	if fake.deleteVolumeAccessPointReturnsOnCall == nil {
		fake.deleteVolumeAccessPointReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteVolumeAccessPointReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) DetachVolume(arg1 provider.VolumeAttachmentRequest) (*http.Response, error) {
	fake.detachVolumeMutex.Lock()
	ret, specificReturn := fake.detachVolumeReturnsOnCall[len(fake.detachVolumeArgsForCall)]
	fake.detachVolumeArgsForCall = append(fake.detachVolumeArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	stub := fake.DetachVolumeStub
	fakeReturns := fake.detachVolumeReturns
	fake.recordInvocation("DetachVolume", []interface{}{arg1})
	fake.detachVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) DetachVolumeCallCount() int {
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	return len(fake.detachVolumeArgsForCall)
}

func (fake *FakeSession) DetachVolumeCalls(stub func(provider.VolumeAttachmentRequest) (*http.Response, error)) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = stub
}

func (fake *FakeSession) DetachVolumeArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	argsForCall := fake.detachVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) DetachVolumeReturns(result1 *http.Response, result2 error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = nil
	fake.detachVolumeReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) DetachVolumeReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = nil
	if fake.detachVolumeReturnsOnCall == nil {
		fake.detachVolumeReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.detachVolumeReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ExpandVolume(arg1 provider.ExpandVolumeRequest) (int64, error) {
	fake.expandVolumeMutex.Lock()
	ret, specificReturn := fake.expandVolumeReturnsOnCall[len(fake.expandVolumeArgsForCall)]
	fake.expandVolumeArgsForCall = append(fake.expandVolumeArgsForCall, struct {
		arg1 provider.ExpandVolumeRequest
	}{arg1})
	stub := fake.ExpandVolumeStub
	fakeReturns := fake.expandVolumeReturns
	fake.recordInvocation("ExpandVolume", []interface{}{arg1})
	fake.expandVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) ExpandVolumeCallCount() int {
	fake.expandVolumeMutex.RLock()
	defer fake.expandVolumeMutex.RUnlock()
	return len(fake.expandVolumeArgsForCall)
}

func (fake *FakeSession) ExpandVolumeCalls(stub func(provider.ExpandVolumeRequest) (int64, error)) {
	fake.expandVolumeMutex.Lock()
	defer fake.expandVolumeMutex.Unlock()
	fake.ExpandVolumeStub = stub
}

func (fake *FakeSession) ExpandVolumeArgsForCall(i int) provider.ExpandVolumeRequest {
	fake.expandVolumeMutex.RLock()
	defer fake.expandVolumeMutex.RUnlock()
	argsForCall := fake.expandVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) ExpandVolumeReturns(result1 int64, result2 error) {
	fake.expandVolumeMutex.Lock()
	defer fake.expandVolumeMutex.Unlock()
	fake.ExpandVolumeStub = nil
	fake.expandVolumeReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ExpandVolumeReturnsOnCall(i int, result1 int64, result2 error) {
	fake.expandVolumeMutex.Lock()
	defer fake.expandVolumeMutex.Unlock()
	fake.ExpandVolumeStub = nil
	if fake.expandVolumeReturnsOnCall == nil {
		fake.expandVolumeReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.expandVolumeReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetProviderDisplayName() provider.VolumeProvider {
	fake.getProviderDisplayNameMutex.Lock()
	ret, specificReturn := fake.getProviderDisplayNameReturnsOnCall[len(fake.getProviderDisplayNameArgsForCall)]
	fake.getProviderDisplayNameArgsForCall = append(fake.getProviderDisplayNameArgsForCall, struct {
	}{})
	stub := fake.GetProviderDisplayNameStub
	fakeReturns := fake.getProviderDisplayNameReturns
	fake.recordInvocation("GetProviderDisplayName", []interface{}{})
	fake.getProviderDisplayNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) GetProviderDisplayNameCallCount() int {
	fake.getProviderDisplayNameMutex.RLock()
	defer fake.getProviderDisplayNameMutex.RUnlock()
	return len(fake.getProviderDisplayNameArgsForCall)
}

func (fake *FakeSession) GetProviderDisplayNameCalls(stub func() provider.VolumeProvider) {
	fake.getProviderDisplayNameMutex.Lock()
	defer fake.getProviderDisplayNameMutex.Unlock()
	fake.GetProviderDisplayNameStub = stub
}

func (fake *FakeSession) GetProviderDisplayNameReturns(result1 provider.VolumeProvider) {
	fake.getProviderDisplayNameMutex.Lock()
	defer fake.getProviderDisplayNameMutex.Unlock()
	fake.GetProviderDisplayNameStub = nil
	fake.getProviderDisplayNameReturns = struct {
		result1 provider.VolumeProvider
	}{result1}
}

func (fake *FakeSession) GetProviderDisplayNameReturnsOnCall(i int, result1 provider.VolumeProvider) {
	fake.getProviderDisplayNameMutex.Lock()
	defer fake.getProviderDisplayNameMutex.Unlock()
	fake.GetProviderDisplayNameStub = nil
	if fake.getProviderDisplayNameReturnsOnCall == nil {
		fake.getProviderDisplayNameReturnsOnCall = make(map[int]struct {
			result1 provider.VolumeProvider
		})
	}
	fake.getProviderDisplayNameReturnsOnCall[i] = struct {
		result1 provider.VolumeProvider
	}{result1}
}

func (fake *FakeSession) GetSnapshot(arg1 string) (*provider.Snapshot, error) {
	fake.getSnapshotMutex.Lock()
	ret, specificReturn := fake.getSnapshotReturnsOnCall[len(fake.getSnapshotArgsForCall)]
	fake.getSnapshotArgsForCall = append(fake.getSnapshotArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSnapshotStub
	fakeReturns := fake.getSnapshotReturns
	fake.recordInvocation("GetSnapshot", []interface{}{arg1})
	fake.getSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetSnapshotCallCount() int {
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	return len(fake.getSnapshotArgsForCall)
}

func (fake *FakeSession) GetSnapshotCalls(stub func(string) (*provider.Snapshot, error)) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = stub
}

func (fake *FakeSession) GetSnapshotArgsForCall(i int) string {
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	argsForCall := fake.getSnapshotArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetSnapshotReturns(result1 *provider.Snapshot, result2 error) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = nil
	fake.getSnapshotReturns = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetSnapshotReturnsOnCall(i int, result1 *provider.Snapshot, result2 error) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = nil
	if fake.getSnapshotReturnsOnCall == nil {
		fake.getSnapshotReturnsOnCall = make(map[int]struct {
			result1 *provider.Snapshot
			result2 error
		})
	}
	fake.getSnapshotReturnsOnCall[i] = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetSnapshotByName(arg1 string) (*provider.Snapshot, error) {
	fake.getSnapshotByNameMutex.Lock()
	ret, specificReturn := fake.getSnapshotByNameReturnsOnCall[len(fake.getSnapshotByNameArgsForCall)]
	fake.getSnapshotByNameArgsForCall = append(fake.getSnapshotByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSnapshotByNameStub
	fakeReturns := fake.getSnapshotByNameReturns
	fake.recordInvocation("GetSnapshotByName", []interface{}{arg1})
	fake.getSnapshotByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetSnapshotByNameCallCount() int {
	fake.getSnapshotByNameMutex.RLock()
	defer fake.getSnapshotByNameMutex.RUnlock()
	return len(fake.getSnapshotByNameArgsForCall)
}

func (fake *FakeSession) GetSnapshotByNameCalls(stub func(string) (*provider.Snapshot, error)) {
	fake.getSnapshotByNameMutex.Lock()
	defer fake.getSnapshotByNameMutex.Unlock()
	fake.GetSnapshotByNameStub = stub
}

func (fake *FakeSession) GetSnapshotByNameArgsForCall(i int) string {
	fake.getSnapshotByNameMutex.RLock()
	defer fake.getSnapshotByNameMutex.RUnlock()
	argsForCall := fake.getSnapshotByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetSnapshotByNameReturns(result1 *provider.Snapshot, result2 error) {
	fake.getSnapshotByNameMutex.Lock()
	defer fake.getSnapshotByNameMutex.Unlock()
	fake.GetSnapshotByNameStub = nil
	fake.getSnapshotByNameReturns = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetSnapshotByNameReturnsOnCall(i int, result1 *provider.Snapshot, result2 error) {
	fake.getSnapshotByNameMutex.Lock()
	defer fake.getSnapshotByNameMutex.Unlock()
	fake.GetSnapshotByNameStub = nil
	if fake.getSnapshotByNameReturnsOnCall == nil {
		fake.getSnapshotByNameReturnsOnCall = make(map[int]struct {
			result1 *provider.Snapshot
			result2 error
		})
	}
	fake.getSnapshotByNameReturnsOnCall[i] = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolume(arg1 string) (*provider.Volume, error) {
	fake.getVolumeMutex.Lock()
	ret, specificReturn := fake.getVolumeReturnsOnCall[len(fake.getVolumeArgsForCall)]
	fake.getVolumeArgsForCall = append(fake.getVolumeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetVolumeStub
	fakeReturns := fake.getVolumeReturns
	fake.recordInvocation("GetVolume", []interface{}{arg1})
	fake.getVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeCallCount() int {
	fake.getVolumeMutex.RLock()
	defer fake.getVolumeMutex.RUnlock()
	return len(fake.getVolumeArgsForCall)
}

func (fake *FakeSession) GetVolumeCalls(stub func(string) (*provider.Volume, error)) {
	fake.getVolumeMutex.Lock()
	defer fake.getVolumeMutex.Unlock()
	fake.GetVolumeStub = stub
}

func (fake *FakeSession) GetVolumeArgsForCall(i int) string {
	fake.getVolumeMutex.RLock()
	defer fake.getVolumeMutex.RUnlock()
	argsForCall := fake.getVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeReturns(result1 *provider.Volume, result2 error) {
	fake.getVolumeMutex.Lock()
	defer fake.getVolumeMutex.Unlock()
	fake.GetVolumeStub = nil
	fake.getVolumeReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.getVolumeMutex.Lock()
	defer fake.getVolumeMutex.Unlock()
	fake.GetVolumeStub = nil
	if fake.getVolumeReturnsOnCall == nil {
		fake.getVolumeReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.getVolumeReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeAccessPoint(arg1 provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error) {
	fake.getVolumeAccessPointMutex.Lock()
	ret, specificReturn := fake.getVolumeAccessPointReturnsOnCall[len(fake.getVolumeAccessPointArgsForCall)]
	fake.getVolumeAccessPointArgsForCall = append(fake.getVolumeAccessPointArgsForCall, struct {
		arg1 provider.VolumeAccessPointRequest
	}{arg1})
	stub := fake.GetVolumeAccessPointStub
	fakeReturns := fake.getVolumeAccessPointReturns
	fake.recordInvocation("GetVolumeAccessPoint", []interface{}{arg1})
	fake.getVolumeAccessPointMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeAccessPointCallCount() int {
	fake.getVolumeAccessPointMutex.RLock()
	defer fake.getVolumeAccessPointMutex.RUnlock()
	return len(fake.getVolumeAccessPointArgsForCall)
}

func (fake *FakeSession) GetVolumeAccessPointCalls(stub func(provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error)) {
	fake.getVolumeAccessPointMutex.Lock()
	defer fake.getVolumeAccessPointMutex.Unlock()
	fake.GetVolumeAccessPointStub = stub
}

func (fake *FakeSession) GetVolumeAccessPointArgsForCall(i int) provider.VolumeAccessPointRequest {
	fake.getVolumeAccessPointMutex.RLock()
	defer fake.getVolumeAccessPointMutex.RUnlock()
	argsForCall := fake.getVolumeAccessPointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeAccessPointReturns(result1 *provider.VolumeAccessPointResponse, result2 error) {
	fake.getVolumeAccessPointMutex.Lock()
	defer fake.getVolumeAccessPointMutex.Unlock()
	fake.GetVolumeAccessPointStub = nil
	fake.getVolumeAccessPointReturns = struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeAccessPointReturnsOnCall(i int, result1 *provider.VolumeAccessPointResponse, result2 error) {
	fake.getVolumeAccessPointMutex.Lock()
	defer fake.getVolumeAccessPointMutex.Unlock()
	fake.GetVolumeAccessPointStub = nil
	if fake.getVolumeAccessPointReturnsOnCall == nil {
		fake.getVolumeAccessPointReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAccessPointResponse
			result2 error
		})
	}
	fake.getVolumeAccessPointReturnsOnCall[i] = struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeAttachment(arg1 provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) {
	fake.getVolumeAttachmentMutex.Lock()
	ret, specificReturn := fake.getVolumeAttachmentReturnsOnCall[len(fake.getVolumeAttachmentArgsForCall)]
	fake.getVolumeAttachmentArgsForCall = append(fake.getVolumeAttachmentArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	stub := fake.GetVolumeAttachmentStub
	fakeReturns := fake.getVolumeAttachmentReturns
	fake.recordInvocation("GetVolumeAttachment", []interface{}{arg1})
	fake.getVolumeAttachmentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeAttachmentCallCount() int {
	fake.getVolumeAttachmentMutex.RLock()
	defer fake.getVolumeAttachmentMutex.RUnlock()
	return len(fake.getVolumeAttachmentArgsForCall)
}

func (fake *FakeSession) GetVolumeAttachmentCalls(stub func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)) {
	fake.getVolumeAttachmentMutex.Lock()
	defer fake.getVolumeAttachmentMutex.Unlock()
	fake.GetVolumeAttachmentStub = stub
}

func (fake *FakeSession) GetVolumeAttachmentArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.getVolumeAttachmentMutex.RLock()
	defer fake.getVolumeAttachmentMutex.RUnlock()
	argsForCall := fake.getVolumeAttachmentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeAttachmentReturns(result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.getVolumeAttachmentMutex.Lock()
	defer fake.getVolumeAttachmentMutex.Unlock()
	fake.GetVolumeAttachmentStub = nil
	fake.getVolumeAttachmentReturns = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeAttachmentReturnsOnCall(i int, result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.getVolumeAttachmentMutex.Lock()
	defer fake.getVolumeAttachmentMutex.Unlock()
	fake.GetVolumeAttachmentStub = nil
	if fake.getVolumeAttachmentReturnsOnCall == nil {
		fake.getVolumeAttachmentReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAttachmentResponse
			result2 error
		})
	}
	fake.getVolumeAttachmentReturnsOnCall[i] = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeByName(arg1 string) (*provider.Volume, error) {
	fake.getVolumeByNameMutex.Lock()
	ret, specificReturn := fake.getVolumeByNameReturnsOnCall[len(fake.getVolumeByNameArgsForCall)]
	fake.getVolumeByNameArgsForCall = append(fake.getVolumeByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetVolumeByNameStub
	fakeReturns := fake.getVolumeByNameReturns
	fake.recordInvocation("GetVolumeByName", []interface{}{arg1})
	fake.getVolumeByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeByNameCallCount() int {
	fake.getVolumeByNameMutex.RLock()
	defer fake.getVolumeByNameMutex.RUnlock()
	return len(fake.getVolumeByNameArgsForCall)
}

func (fake *FakeSession) GetVolumeByNameCalls(stub func(string) (*provider.Volume, error)) {
	fake.getVolumeByNameMutex.Lock()
	defer fake.getVolumeByNameMutex.Unlock()
	fake.GetVolumeByNameStub = stub
}

func (fake *FakeSession) GetVolumeByNameArgsForCall(i int) string {
	fake.getVolumeByNameMutex.RLock()
	defer fake.getVolumeByNameMutex.RUnlock()
	argsForCall := fake.getVolumeByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeByNameReturns(result1 *provider.Volume, result2 error) {
	fake.getVolumeByNameMutex.Lock()
	defer fake.getVolumeByNameMutex.Unlock()
	fake.GetVolumeByNameStub = nil
	fake.getVolumeByNameReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeByNameReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.getVolumeByNameMutex.Lock()
	defer fake.getVolumeByNameMutex.Unlock()
	fake.GetVolumeByNameStub = nil
	if fake.getVolumeByNameReturnsOnCall == nil {
		fake.getVolumeByNameReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.getVolumeByNameReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeByRequestID(arg1 string) (*provider.Volume, error) {
	fake.getVolumeByRequestIDMutex.Lock()
	ret, specificReturn := fake.getVolumeByRequestIDReturnsOnCall[len(fake.getVolumeByRequestIDArgsForCall)]
	fake.getVolumeByRequestIDArgsForCall = append(fake.getVolumeByRequestIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetVolumeByRequestIDStub
	fakeReturns := fake.getVolumeByRequestIDReturns
	fake.recordInvocation("GetVolumeByRequestID", []interface{}{arg1})
	fake.getVolumeByRequestIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeByRequestIDCallCount() int {
	fake.getVolumeByRequestIDMutex.RLock()
	defer fake.getVolumeByRequestIDMutex.RUnlock()
	return len(fake.getVolumeByRequestIDArgsForCall)
}

func (fake *FakeSession) GetVolumeByRequestIDCalls(stub func(string) (*provider.Volume, error)) {
	fake.getVolumeByRequestIDMutex.Lock()
	defer fake.getVolumeByRequestIDMutex.Unlock()
	fake.GetVolumeByRequestIDStub = stub
}

func (fake *FakeSession) GetVolumeByRequestIDArgsForCall(i int) string {
	fake.getVolumeByRequestIDMutex.RLock()
	defer fake.getVolumeByRequestIDMutex.RUnlock()
	argsForCall := fake.getVolumeByRequestIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeByRequestIDReturns(result1 *provider.Volume, result2 error) {
	fake.getVolumeByRequestIDMutex.Lock()
	defer fake.getVolumeByRequestIDMutex.Unlock()
	fake.GetVolumeByRequestIDStub = nil
	fake.getVolumeByRequestIDReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeByRequestIDReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.getVolumeByRequestIDMutex.Lock()
	defer fake.getVolumeByRequestIDMutex.Unlock()
	fake.GetVolumeByRequestIDStub = nil
	if fake.getVolumeByRequestIDReturnsOnCall == nil {
		fake.getVolumeByRequestIDReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.getVolumeByRequestIDReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListSnapshots(arg1 int, arg2 string, arg3 map[string]string) (*provider.SnapshotList, error) {
	fake.listSnapshotsMutex.Lock()
	ret, specificReturn := fake.listSnapshotsReturnsOnCall[len(fake.listSnapshotsArgsForCall)]
	fake.listSnapshotsArgsForCall = append(fake.listSnapshotsArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 map[string]string
	}{arg1, arg2, arg3})
	stub := fake.ListSnapshotsStub
	fakeReturns := fake.listSnapshotsReturns
	fake.recordInvocation("ListSnapshots", []interface{}{arg1, arg2, arg3})
	fake.listSnapshotsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) ListSnapshotsCallCount() int {
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	return len(fake.listSnapshotsArgsForCall)
}

func (fake *FakeSession) ListSnapshotsCalls(stub func(int, string, map[string]string) (*provider.SnapshotList, error)) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = stub
}

func (fake *FakeSession) ListSnapshotsArgsForCall(i int) (int, string, map[string]string) {
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	argsForCall := fake.listSnapshotsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSession) ListSnapshotsReturns(result1 *provider.SnapshotList, result2 error) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = nil
	fake.listSnapshotsReturns = struct {
		result1 *provider.SnapshotList
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListSnapshotsReturnsOnCall(i int, result1 *provider.SnapshotList, result2 error) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = nil
	if fake.listSnapshotsReturnsOnCall == nil {
		fake.listSnapshotsReturnsOnCall = make(map[int]struct {
			result1 *provider.SnapshotList
			result2 error
		})
	}
	fake.listSnapshotsReturnsOnCall[i] = struct {
		result1 *provider.SnapshotList
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListVolumes(arg1 int, arg2 string, arg3 map[string]string) (*provider.VolumeList, error) {
	fake.listVolumesMutex.Lock()
	ret, specificReturn := fake.listVolumesReturnsOnCall[len(fake.listVolumesArgsForCall)]
	fake.listVolumesArgsForCall = append(fake.listVolumesArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 map[string]string
	}{arg1, arg2, arg3})
	stub := fake.ListVolumesStub
	fakeReturns := fake.listVolumesReturns
	fake.recordInvocation("ListVolumes", []interface{}{arg1, arg2, arg3})
	fake.listVolumesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) ListVolumesCallCount() int {
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	return len(fake.listVolumesArgsForCall)
}

func (fake *FakeSession) ListVolumesCalls(stub func(int, string, map[string]string) (*provider.VolumeList, error)) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = stub
}

func (fake *FakeSession) ListVolumesArgsForCall(i int) (int, string, map[string]string) {
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	argsForCall := fake.listVolumesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSession) ListVolumesReturns(result1 *provider.VolumeList, result2 error) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = nil
	fake.listVolumesReturns = struct {
		result1 *provider.VolumeList
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListVolumesReturnsOnCall(i int, result1 *provider.VolumeList, result2 error) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = nil
	if fake.listVolumesReturnsOnCall == nil {
		fake.listVolumesReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeList
			result2 error
		})
	}
	fake.listVolumesReturnsOnCall[i] = struct {
		result1 *provider.VolumeList
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ProviderName() provider.VolumeProvider {
	fake.providerNameMutex.Lock()
	ret, specificReturn := fake.providerNameReturnsOnCall[len(fake.providerNameArgsForCall)]
	fake.providerNameArgsForCall = append(fake.providerNameArgsForCall, struct {
	}{})
	stub := fake.ProviderNameStub
	fakeReturns := fake.providerNameReturns
	fake.recordInvocation("ProviderName", []interface{}{})
	fake.providerNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) ProviderNameCallCount() int {
	fake.providerNameMutex.RLock()
	defer fake.providerNameMutex.RUnlock()
	return len(fake.providerNameArgsForCall)
}

func (fake *FakeSession) ProviderNameCalls(stub func() provider.VolumeProvider) {
	fake.providerNameMutex.Lock()
	defer fake.providerNameMutex.Unlock()
	fake.ProviderNameStub = stub
}

func (fake *FakeSession) ProviderNameReturns(result1 provider.VolumeProvider) {
	fake.providerNameMutex.Lock()
	defer fake.providerNameMutex.Unlock()
	fake.ProviderNameStub = nil
	fake.providerNameReturns = struct {
		result1 provider.VolumeProvider
	}{result1}
}

func (fake *FakeSession) ProviderNameReturnsOnCall(i int, result1 provider.VolumeProvider) {
	fake.providerNameMutex.Lock()
	defer fake.providerNameMutex.Unlock()
	fake.ProviderNameStub = nil
	if fake.providerNameReturnsOnCall == nil {
		fake.providerNameReturnsOnCall = make(map[int]struct {
			result1 provider.VolumeProvider
		})
	}
	fake.providerNameReturnsOnCall[i] = struct {
		result1 provider.VolumeProvider
	}{result1}
}

func (fake *FakeSession) Type() provider.VolumeType {
	fake.typeMutex.Lock()
	ret, specificReturn := fake.typeReturnsOnCall[len(fake.typeArgsForCall)]
	fake.typeArgsForCall = append(fake.typeArgsForCall, struct {
	}{})
	stub := fake.TypeStub
	fakeReturns := fake.typeReturns
	fake.recordInvocation("Type", []interface{}{})
	fake.typeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) TypeCallCount() int {
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	return len(fake.typeArgsForCall)
}

func (fake *FakeSession) TypeCalls(stub func() provider.VolumeType) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = stub
}

func (fake *FakeSession) TypeReturns(result1 provider.VolumeType) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = nil
	fake.typeReturns = struct {
		result1 provider.VolumeType
	}{result1}
}

func (fake *FakeSession) TypeReturnsOnCall(i int, result1 provider.VolumeType) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = nil
	if fake.typeReturnsOnCall == nil {
		fake.typeReturnsOnCall = make(map[int]struct {
			result1 provider.VolumeType
		})
	}
	fake.typeReturnsOnCall[i] = struct {
		result1 provider.VolumeType
	}{result1}
}

func (fake *FakeSession) UpdateVolume(arg1 provider.Volume) error {
	fake.updateVolumeMutex.Lock()
	ret, specificReturn := fake.updateVolumeReturnsOnCall[len(fake.updateVolumeArgsForCall)]
	fake.updateVolumeArgsForCall = append(fake.updateVolumeArgsForCall, struct {
		arg1 provider.Volume
	}{arg1})
	stub := fake.UpdateVolumeStub
	fakeReturns := fake.updateVolumeReturns
	fake.recordInvocation("UpdateVolume", []interface{}{arg1})
	fake.updateVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) UpdateVolumeCallCount() int {
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	return len(fake.updateVolumeArgsForCall)
}

func (fake *FakeSession) UpdateVolumeCalls(stub func(provider.Volume) error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = stub
}

func (fake *FakeSession) UpdateVolumeArgsForCall(i int) provider.Volume {
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	argsForCall := fake.updateVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) UpdateVolumeReturns(result1 error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = nil
	fake.updateVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) UpdateVolumeReturnsOnCall(i int, result1 error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = nil
	if fake.updateVolumeReturnsOnCall == nil {
		fake.updateVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) WaitForAttachVolume(arg1 provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) {
	fake.waitForAttachVolumeMutex.Lock()
	ret, specificReturn := fake.waitForAttachVolumeReturnsOnCall[len(fake.waitForAttachVolumeArgsForCall)]
	fake.waitForAttachVolumeArgsForCall = append(fake.waitForAttachVolumeArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	stub := fake.WaitForAttachVolumeStub
	fakeReturns := fake.waitForAttachVolumeReturns
	fake.recordInvocation("WaitForAttachVolume", []interface{}{arg1})
	fake.waitForAttachVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) WaitForAttachVolumeCallCount() int {
	fake.waitForAttachVolumeMutex.RLock()
	defer fake.waitForAttachVolumeMutex.RUnlock()
	return len(fake.waitForAttachVolumeArgsForCall)
}

func (fake *FakeSession) WaitForAttachVolumeCalls(stub func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)) {
	fake.waitForAttachVolumeMutex.Lock()
	defer fake.waitForAttachVolumeMutex.Unlock()
	fake.WaitForAttachVolumeStub = stub
}

func (fake *FakeSession) WaitForAttachVolumeArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.waitForAttachVolumeMutex.RLock()
	defer fake.waitForAttachVolumeMutex.RUnlock()
	argsForCall := fake.waitForAttachVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) WaitForAttachVolumeReturns(result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.waitForAttachVolumeMutex.Lock()
	defer fake.waitForAttachVolumeMutex.Unlock()
	fake.WaitForAttachVolumeStub = nil
	fake.waitForAttachVolumeReturns = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) WaitForAttachVolumeReturnsOnCall(i int, result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.waitForAttachVolumeMutex.Lock()
	defer fake.waitForAttachVolumeMutex.Unlock()
	fake.WaitForAttachVolumeStub = nil
	if fake.waitForAttachVolumeReturnsOnCall == nil {
		fake.waitForAttachVolumeReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAttachmentResponse
			result2 error
		})
	}
	fake.waitForAttachVolumeReturnsOnCall[i] = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) WaitForCreateVolumeAccessPoint(arg1 provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error) {
	fake.waitForCreateVolumeAccessPointMutex.Lock()
	ret, specificReturn := fake.waitForCreateVolumeAccessPointReturnsOnCall[len(fake.waitForCreateVolumeAccessPointArgsForCall)]
	fake.waitForCreateVolumeAccessPointArgsForCall = append(fake.waitForCreateVolumeAccessPointArgsForCall, struct {
		arg1 provider.VolumeAccessPointRequest
	}{arg1})
	stub := fake.WaitForCreateVolumeAccessPointStub
	fakeReturns := fake.waitForCreateVolumeAccessPointReturns
	fake.recordInvocation("WaitForCreateVolumeAccessPoint", []interface{}{arg1})
	fake.waitForCreateVolumeAccessPointMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) WaitForCreateVolumeAccessPointCallCount() int {
	fake.waitForCreateVolumeAccessPointMutex.RLock()
	defer fake.waitForCreateVolumeAccessPointMutex.RUnlock()
	return len(fake.waitForCreateVolumeAccessPointArgsForCall)
}

func (fake *FakeSession) WaitForCreateVolumeAccessPointCalls(stub func(provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error)) {
	fake.waitForCreateVolumeAccessPointMutex.Lock()
	defer fake.waitForCreateVolumeAccessPointMutex.Unlock()
	fake.WaitForCreateVolumeAccessPointStub = stub
}

func (fake *FakeSession) WaitForCreateVolumeAccessPointArgsForCall(i int) provider.VolumeAccessPointRequest {
	fake.waitForCreateVolumeAccessPointMutex.RLock()
	defer fake.waitForCreateVolumeAccessPointMutex.RUnlock()
	argsForCall := fake.waitForCreateVolumeAccessPointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) WaitForCreateVolumeAccessPointReturns(result1 *provider.VolumeAccessPointResponse, result2 error) {
	fake.waitForCreateVolumeAccessPointMutex.Lock()
	defer fake.waitForCreateVolumeAccessPointMutex.Unlock()
	fake.WaitForCreateVolumeAccessPointStub = nil
	fake.waitForCreateVolumeAccessPointReturns = struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) WaitForCreateVolumeAccessPointReturnsOnCall(i int, result1 *provider.VolumeAccessPointResponse, result2 error) {
	fake.waitForCreateVolumeAccessPointMutex.Lock()
	defer fake.waitForCreateVolumeAccessPointMutex.Unlock()
	fake.WaitForCreateVolumeAccessPointStub = nil
	if fake.waitForCreateVolumeAccessPointReturnsOnCall == nil {
		fake.waitForCreateVolumeAccessPointReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAccessPointResponse
			result2 error
		})
	}
	fake.waitForCreateVolumeAccessPointReturnsOnCall[i] = struct {
		result1 *provider.VolumeAccessPointResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) WaitForDeleteVolumeAccessPoint(arg1 provider.VolumeAccessPointRequest) error {
	fake.waitForDeleteVolumeAccessPointMutex.Lock()
	ret, specificReturn := fake.waitForDeleteVolumeAccessPointReturnsOnCall[len(fake.waitForDeleteVolumeAccessPointArgsForCall)]
	fake.waitForDeleteVolumeAccessPointArgsForCall = append(fake.waitForDeleteVolumeAccessPointArgsForCall, struct {
		arg1 provider.VolumeAccessPointRequest
	}{arg1})
	stub := fake.WaitForDeleteVolumeAccessPointStub
	fakeReturns := fake.waitForDeleteVolumeAccessPointReturns
	fake.recordInvocation("WaitForDeleteVolumeAccessPoint", []interface{}{arg1})
	fake.waitForDeleteVolumeAccessPointMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) WaitForDeleteVolumeAccessPointCallCount() int {
	fake.waitForDeleteVolumeAccessPointMutex.RLock()
	defer fake.waitForDeleteVolumeAccessPointMutex.RUnlock()
	return len(fake.waitForDeleteVolumeAccessPointArgsForCall)
}

func (fake *FakeSession) WaitForDeleteVolumeAccessPointCalls(stub func(provider.VolumeAccessPointRequest) error) {
	fake.waitForDeleteVolumeAccessPointMutex.Lock()
	defer fake.waitForDeleteVolumeAccessPointMutex.Unlock()
	fake.WaitForDeleteVolumeAccessPointStub = stub
}

func (fake *FakeSession) WaitForDeleteVolumeAccessPointArgsForCall(i int) provider.VolumeAccessPointRequest {
	fake.waitForDeleteVolumeAccessPointMutex.RLock()
	defer fake.waitForDeleteVolumeAccessPointMutex.RUnlock()
	argsForCall := fake.waitForDeleteVolumeAccessPointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) WaitForDeleteVolumeAccessPointReturns(result1 error) {
	fake.waitForDeleteVolumeAccessPointMutex.Lock()
	defer fake.waitForDeleteVolumeAccessPointMutex.Unlock()
	fake.WaitForDeleteVolumeAccessPointStub = nil
	fake.waitForDeleteVolumeAccessPointReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) WaitForDeleteVolumeAccessPointReturnsOnCall(i int, result1 error) {
	fake.waitForDeleteVolumeAccessPointMutex.Lock()
	defer fake.waitForDeleteVolumeAccessPointMutex.Unlock()
	fake.WaitForDeleteVolumeAccessPointStub = nil
	if fake.waitForDeleteVolumeAccessPointReturnsOnCall == nil {
		fake.waitForDeleteVolumeAccessPointReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForDeleteVolumeAccessPointReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) WaitForDetachVolume(arg1 provider.VolumeAttachmentRequest) error {
	fake.waitForDetachVolumeMutex.Lock()
	ret, specificReturn := fake.waitForDetachVolumeReturnsOnCall[len(fake.waitForDetachVolumeArgsForCall)]
	fake.waitForDetachVolumeArgsForCall = append(fake.waitForDetachVolumeArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	stub := fake.WaitForDetachVolumeStub
	fakeReturns := fake.waitForDetachVolumeReturns
	fake.recordInvocation("WaitForDetachVolume", []interface{}{arg1})
	fake.waitForDetachVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSession) WaitForDetachVolumeCallCount() int {
	fake.waitForDetachVolumeMutex.RLock()
	defer fake.waitForDetachVolumeMutex.RUnlock()
	return len(fake.waitForDetachVolumeArgsForCall)
}

func (fake *FakeSession) WaitForDetachVolumeCalls(stub func(provider.VolumeAttachmentRequest) error) {
	fake.waitForDetachVolumeMutex.Lock()
	defer fake.waitForDetachVolumeMutex.Unlock()
	fake.WaitForDetachVolumeStub = stub
}

func (fake *FakeSession) WaitForDetachVolumeArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.waitForDetachVolumeMutex.RLock()
	defer fake.waitForDetachVolumeMutex.RUnlock()
	argsForCall := fake.waitForDetachVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) WaitForDetachVolumeReturns(result1 error) {
	fake.waitForDetachVolumeMutex.Lock()
	defer fake.waitForDetachVolumeMutex.Unlock()
	fake.WaitForDetachVolumeStub = nil
	fake.waitForDetachVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) WaitForDetachVolumeReturnsOnCall(i int, result1 error) {
	fake.waitForDetachVolumeMutex.Lock()
	defer fake.waitForDetachVolumeMutex.Unlock()
	fake.WaitForDetachVolumeStub = nil
	if fake.waitForDetachVolumeReturnsOnCall == nil {
		fake.waitForDetachVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForDetachVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	fake.authorizeVolumeMutex.RLock()
	defer fake.authorizeVolumeMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.createVolumeAccessPointMutex.RLock()
	defer fake.createVolumeAccessPointMutex.RUnlock()
	fake.createVolumeFromSnapshotMutex.RLock()
	defer fake.createVolumeFromSnapshotMutex.RUnlock()
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	fake.deleteVolumeMutex.RLock()
	defer fake.deleteVolumeMutex.RUnlock()
	fake.deleteVolumeAccessPointMutex.RLock()
	defer fake.deleteVolumeAccessPointMutex.RUnlock()
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	fake.expandVolumeMutex.RLock()
	defer fake.expandVolumeMutex.RUnlock()
	fake.getProviderDisplayNameMutex.RLock()
	defer fake.getProviderDisplayNameMutex.RUnlock()
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	fake.getSnapshotByNameMutex.RLock()
	defer fake.getSnapshotByNameMutex.RUnlock()
	fake.getVolumeMutex.RLock()
	defer fake.getVolumeMutex.RUnlock()
	fake.getVolumeAccessPointMutex.RLock()
	defer fake.getVolumeAccessPointMutex.RUnlock()
	fake.getVolumeAttachmentMutex.RLock()
	defer fake.getVolumeAttachmentMutex.RUnlock()
	fake.getVolumeByNameMutex.RLock()
	defer fake.getVolumeByNameMutex.RUnlock()
	fake.getVolumeByRequestIDMutex.RLock()
	defer fake.getVolumeByRequestIDMutex.RUnlock()
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	fake.providerNameMutex.RLock()
	defer fake.providerNameMutex.RUnlock()
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	fake.waitForAttachVolumeMutex.RLock()
	defer fake.waitForAttachVolumeMutex.RUnlock()
	fake.waitForCreateVolumeAccessPointMutex.RLock()
	defer fake.waitForCreateVolumeAccessPointMutex.RUnlock()
	fake.waitForDeleteVolumeAccessPointMutex.RLock()
	defer fake.waitForDeleteVolumeAccessPointMutex.RUnlock()
	fake.waitForDetachVolumeMutex.RLock()
	defer fake.waitForDetachVolumeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSession) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ provider.Session = new(FakeSession)
